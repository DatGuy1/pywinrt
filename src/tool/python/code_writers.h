#pragma once

namespace pywinrt
{
    template<typename F>
    void write_snake_case(writer& w, std::string_view const& name, F case_func)
    {
        XLANG_ASSERT(name.size() > 0);

        for (std::string_view::size_type i = 0; i < name.size(); i++)
        {
            if (isupper(name[i]) && i > 0)
            {
                static const std::set<std::string_view> casing_exceptions
                    = {"UInt", "IPAddress"};

                auto sub = name.substr(i - 1);
                if (sub[0] != '_'
                    && std::none_of(
                        casing_exceptions.begin(),
                        casing_exceptions.end(),
                        [&sub](std::string_view v)
                        {
                            return sub.substr(0, v.length()) == v;
                        }))
                {
                    w.write('_');
                }
            }

            w.write(case_func(name[i]));
        }
    }

    void write_upper_snake_case(writer& w, std::string_view const& name)
    {
        write_snake_case(
            w,
            name,
            [](char c)
            {
                return static_cast<char>(::toupper(c));
            });
    }

    void write_lower_snake_case(writer& w, std::string_view const& name)
    {
        write_snake_case(
            w,
            name,
            [](char c)
            {
                return static_cast<char>(::tolower(c));
            });
    }

    /**
     * Converts @p name to lower_snake_case and adds a trailing underscore if
     * @p name is a Python keyword.
     *
     * https://docs.python.org/3/reference/lexical_analysis.html#keywords
     */
    void write_lower_snake_case_python_identifier(
        writer& w, std::string_view const& name)
    {
        auto identifier = w.write_temp("%", bind<write_lower_snake_case>(name));

        w.write(identifier);

        std::vector<std::string> keywords{
            "and",      "as",       "assert", "async", "await",  "break",  "class",
            "continue", "def",      "del",    "elif",  "else",   "except", "finally",
            "for",      "from",     "global", "if",    "import", "in",     "is",
            "lambda",   "nonlocal", "not",    "or",    "pass",   "raise",  "return",
            "try",      "while",    "with",   "yield",
        };

        // add trailing underscore to avoid keyword clashes
        if (std::find(keywords.begin(), keywords.end(), identifier) != keywords.end())
        {
            w.write("_");
        }
    }

    void write_lower_case(writer& w, std::string_view const& ns)
    {
        for (auto c : ns)
        {
            w.write(static_cast<char>(::tolower(c)));
        }
    }

    void write_license(writer& w, std::string_view comment_marker = "//")
    {
        w.write(
            "% WARNING: Please don't edit this file. It was generated by Python/WinRT v%\n\n",
            comment_marker,
            XLANG_VERSION_STRING);
    }

    void write_python_setup_filenames(
        writer& w, std::vector<std::string> const& namespaces)
    {
        XLANG_ASSERT(namespaces.size() > 0);

        for (auto&& ns : namespaces)
        {
            w.write("'%/src/py.%.cpp', ", settings.module, ns);
        }

        w.write("'%/src/_winrt.cpp'", settings.module);
    }

    void write_python_import_type(writer& w, TypeDef const& type)
    {
        if (!is_exclusive_to(type))
        {
            w.write("@ = _ns_module.@\n", type.TypeName(), type.TypeName());
        }
    }

    void write_python_import_namespace(writer& w, std::string_view const& ns)
    {
        w.write(
            "\ntry:\n    import %.%\nexcept Exception:\n    pass\n",
            settings.module,
            bind<write_lower_case>(ns));
    }

    void write_python_enum(writer& w, TypeDef const& type)
    {
        w.write(
            "\nclass %(enum.%):\n",
            type.TypeName(),
            is_flags_enum(type) ? "IntFlag" : "IntEnum");
        {
            writer::indent_guard g{w};

            for (auto&& field : type.FieldList())
            {
                if (auto constant = field.Constant())
                {
                    w.write(
                        "% = %\n",
                        bind<write_upper_snake_case>(field.Name()),
                        *constant);
                }
            }
        }

        w.write("\n_ns_module._register_%(%)\n", type.TypeName(), type.TypeName());
    }

    void write_include(writer& w, std::string_view const& ns)
    {
        if (w.current_namespace != ns)
        {
            auto format = R"(
#if __has_include("py.%.h")
#include "py.%.h"
#endif
)";
            w.write(format, ns, ns);
        }
        else
        {
            w.write("#include \"py.%.h\"\n", ns);
        }
    }

    // All generated try/catch blocks go thru this function in order to have a single
    // place to change as we test the binary size of different approaches
    void write_try_catch(
        writer& w,
        std::function<void(writer&)> tryfunc,
        std::string_view exception_return_value = "nullptr")
    {
        w.write("try\n{\n");
        {
            writer::indent_guard g{w};
            tryfunc(w);
        }
        w.write(
            R"(}
catch (...)
{
    py::to_PyErr();
    return %;
}
)",
            exception_return_value);
    }

    void write_setter_try_catch(writer& w, std::function<void(writer&)> tryfunc)
    {
        w.write(R"(if (arg == nullptr)
{
    PyErr_SetString(PyExc_TypeError, "property delete not supported");
    return -1;
}

)");
        write_try_catch(
            w,
            [&](writer& w)
            {
                tryfunc(w);
            },
            "-1");
    }

    void write_template_arg_name(writer& w, GenericParam const& param)
    {
        w.write(param.Name());
    }

    void write_template_arg(writer& w, GenericParam const& param)
    {
        w.write("typename %", bind<write_template_arg_name>(param));
    }

    void write_type_namespace(writer& w, TypeDef const& type)
    {
        auto segments = get_dotted_name_segments(type.TypeNamespace());
        w.write("%", bind_list("::", segments));
    }

    void write_pywrapper_type(writer& w, TypeDef const& type)
    {
        w.write("py::wrapper::%::@", bind<write_type_namespace>(type), type.TypeName());
    }

    void write_pyproj_type(writer& w, TypeDef const& type)
    {
        w.write("py::proj::%::@", bind<write_type_namespace>(type), type.TypeName());
    }

    void write_pyimpl_type(writer& w, TypeDef const& type)
    {
        w.write("py::impl::%::@", bind<write_type_namespace>(type), type.TypeName());
    }

    void write_python_wrapper_template_type(writer& w, TypeDef const& type)
    {
        if (is_ptype(type))
        {
            write_pyproj_type(w, type);
        }
        else
        {
            w.write("%", type);
        }
    }

    /**
     * Writes the pure Python type specialization struct.
     */
    void write_py_type_specialization_struct(writer& w, TypeDef const& type)
    {
        if (is_exclusive_to(type))
        {
            return;
        }

        auto format = R"(
template<>
struct py_type<%>
{
    static PyObject* get_python_type() noexcept;
};
)";
        w.write(format, bind<write_python_wrapper_template_type>(type));
    }

    /**
     * Writes the pure Python type getter function implemenation.
     */
    void write_get_py_type_definition(writer& w, TypeDef const& type)
    {
        if (is_exclusive_to(type))
        {
            return;
        }

        auto format = R"(
PyObject* py::py_type<%>::get_python_type() noexcept {
    using namespace py::cpp::%;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for %");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_@;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type % is not registered");
        return nullptr;
    }

    return python_type;
}
)";

        w.write(
            format,
            bind<write_python_wrapper_template_type>(type),
            bind<write_type_namespace>(type),
            bind<write_type_namespace>(type),
            type.TypeName(),
            bind<write_python_wrapper_template_type>(type));
    }

    /**
     * Writes the binary extension Python type specialization struct.
     */
    void write_python_type_specialization_struct(writer& w, TypeDef const& type)
    {
        if (is_exclusive_to(type))
            return;

        auto format = R"(
template<>
struct winrt_type<%>
{
    static PyTypeObject* get_python_type() noexcept;
};
)";
        w.write(format, bind<write_python_wrapper_template_type>(type));
    }

    /**
     * Writes the binary extension Python type getter function implemenation.
     */
    void write_get_python_type_definition(writer& w, TypeDef const& type)
    {
        if (is_exclusive_to(type))
        {
            return;
        }

        auto format = R"(
PyTypeObject* py::winrt_type<%>::get_python_type() noexcept {
    using namespace py::cpp::%;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for %");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_@;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type % is not registered");
        return nullptr;
    }

    return python_type;
}
)";

        w.write(
            format,
            bind<write_python_wrapper_template_type>(type),
            bind<write_type_namespace>(type),
            bind<write_type_namespace>(type),
            type.TypeName(),
            bind<write_python_wrapper_template_type>(type));
    }

    void write_python_wrapper_type(writer& w, TypeDef const& type)
    {
        switch (get_category(type))
        {
        case category::class_type:
            w.write("winrt_wrapper");
            break;
        case category::interface_type:
            if (is_ptype(type))
                w.write("winrt_pinterface_wrapper");
            else
                w.write("winrt_wrapper");
            break;
        case category::struct_type:
            w.write("winrt_struct_wrapper");
            break;
        }
    }

    void write_python_wrapper_alias(writer& w, TypeDef const& type)
    {
        if (is_exclusive_to(type))
            return;

        w.write(
            "using @ = py::%<%>;\n",
            type.TypeName(),
            bind<write_python_wrapper_type>(type),
            bind<write_python_wrapper_template_type>(type));
    }

    void write_type_base(writer& w, TypeDef const& type)
    {
        if (has_dealloc(type))
        {
            w.write("bases.get()");
        }
        else
        {
            w.write("nullptr");
        }
    }

    /**
     * Writes a module method table item for a pure Python type registration method.
     */
    void write_ns_module_register_py_type_method_def(writer& w, TypeDef const& type)
    {
        w.write(
            "{\"_register_%\", register_%, METH_O, \"registers type\"},\n",
            type.TypeName(),
            type.TypeName());
    }

    /**
     * Writes the module method table for the namespace module.
     * @param w The writer.
     * @param members The namespace module members.
     */
    void write_ns_module_method_table(
        writer& w, cache::namespace_members const& members)
    {
        w.write("static PyMethodDef module_methods[] = {\n");
        {
            writer::indent_guard g{w};

            settings.filter.bind_each<write_ns_module_register_py_type_method_def>(
                members.enums)(w);

            w.write("{}};\n\n");
        }
    }

    /**
     * Writes the type initialization for a binary extension Python type inside
     * the module init function.
     */
    void write_ns_module_init_python_type(writer& w, TypeDef const& type)
    {
        if (is_exclusive_to(type))
            return;

        w.write(
            "state->type_@ = py::register_python_type(module.get(), type_name_@, &type_spec_@, %);\n",
            type.TypeName(),
            type.TypeName(),
            type.TypeName(),
            bind<write_type_base>(type));

        w.write("if (!state->type_@)\n{\n", type.TypeName());
        {
            writer::indent_guard g{w};

            w.write("return nullptr;\n");
        }
        w.write("}\n\n");

        w.write("Py_INCREF(state->type_@);\n\n", type.TypeName());

        if (implements_ibuffer(type) || implements_imemorybufferreference(type))
        {
            // workaround for https://bugs.python.org/issue40724
            w.write("#if PY_VERSION_HEX < 0x03090000\n");
            w.write(
                "state->type_@->tp_as_buffer = &_PyBufferProcs_@;\n",
                type.TypeName(),
                type.TypeName());
            w.write("#endif\n\n");
        }
    }

    void write_ns_module_name(writer& w, std::string_view const& ns)
    {
        auto segments = get_dotted_name_segments(ns);
        w.write("_%_%", settings.module, bind_list("_", segments));
    }

    /**
     * Writes a struct field to hold a pointer to a pure Python type.
     */
    void write_ns_module_py_type_member(writer& w, TypeDef const& type)
    {
        w.write("PyObject* type_@;\n", type.TypeName());
    }

    /**
     * Writes a struct field to hold a pointer to a binary extension Python type.
     */
    void write_ns_module_python_type_member(writer& w, TypeDef const& type)
    {
        w.write("PyTypeObject* type_@;\n", type.TypeName());
    }

    /**
     * Writes the struct defintion for the namespace module state.
     */
    void write_namespace_module_state_struct(
        writer& w, cache::namespace_members const& members)
    {
        w.write("\nstruct module_state\n{\n");
        {
            writer::indent_guard g{w};

            settings.filter.bind_each<write_ns_module_py_type_member>(members.enums)(w);
            settings.filter.bind_each<write_ns_module_python_type_member>(
                members.classes)(w);
            settings.filter.bind_each<write_ns_module_python_type_member>(
                members.interfaces)(w);
            settings.filter.bind_each<write_ns_module_python_type_member>(
                members.structs)(w);
        }
        w.write("};\n");
    }

    /**
     * Writes the namespace module doc string definition.
     */
    void write_ns_module_doc_string(writer& w, std::string_view const& ns)
    {
        w.write("PyDoc_STRVAR(module_doc, \"@\");\n\n", ns);
    }

    /**
     * Writes one visit statement for a namespace  module traverse function.
     */
    void write_ns_module_visit_member(writer& w, TypeDef const& type)
    {
        w.write("Py_VISIT(state->type_@);\n", type.TypeName());
    }

    /**
     * Writes the namespace module traverse function for use in PyModuleDef.m_traverse.
     */
    void write_ns_module_traverse_func(
        writer& w, cache::namespace_members const& members)
    {
        w.write(
            "\nstatic int module_traverse(PyObject* module, visitproc visit, void* arg) noexcept\n{\n");
        {
            writer::indent_guard g{w};

            w.write(
                "auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));\n\n");

            w.write("if (!state)\n{\n");
            {
                writer::indent_guard gg{w};

                w.write("return 0;\n");
            }
            w.write("}\n\n");

            settings.filter.bind_each<write_ns_module_visit_member>(members.enums)(w);
            settings.filter.bind_each<write_ns_module_visit_member>(members.classes)(w);
            settings.filter.bind_each<write_ns_module_visit_member>(members.interfaces)(
                w);
            settings.filter.bind_each<write_ns_module_visit_member>(members.structs)(w);

            w.write("\nreturn 0;\n");
        }
        w.write("}\n");
    }

    /**
     * Writes one clear statement for a namespace module clear function.
     */
    void write_ns_module_clear_member(writer& w, TypeDef const& type)
    {
        w.write("Py_CLEAR(state->type_@);\n", type.TypeName());
    }

    /**
     * Writes the namespace module clear function for use in PyModuleDef.m_clear.
     */
    void write_ns_module_clear_func(writer& w, cache::namespace_members const& members)
    {
        w.write("\nstatic int module_clear(PyObject* module) noexcept\n{\n");
        {
            writer::indent_guard g{w};

            w.write(
                "auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));\n\n");

            w.write("if (!state)\n{\n");
            {
                writer::indent_guard gg{w};

                w.write("return 0;\n");
            }
            w.write("}\n\n");

            settings.filter.bind_each<write_ns_module_clear_member>(members.enums)(w);
            settings.filter.bind_each<write_ns_module_clear_member>(members.classes)(w);
            settings.filter.bind_each<write_ns_module_clear_member>(members.interfaces)(
                w);
            settings.filter.bind_each<write_ns_module_clear_member>(members.structs)(w);

            w.write("\nreturn 0;\n");
        }
        w.write("}\n\n");
    }

    /**
     * Writes the namespace module definition structure.
     */
    void write_ns_module_def_struct(writer& w, std::string_view const& ns)
    {
        auto format = R"(
static PyModuleDef module_def
    = {PyModuleDef_HEAD_INIT,
       "%",
       module_doc,
       sizeof(module_state),
       module_methods,
       nullptr,
       module_traverse,
       module_clear,
       nullptr};

)";

        w.write(format, bind<write_ns_module_name>(ns));
    }

    /**
     * Writes all namespace initialization members except for the public init function.
     */
    void write_namespace_initialization(
        writer& w, std::string_view const& ns, cache::namespace_members const& members)
    {
        w.write("\n// ----- % Initialization --------------------\n", ns);

        write_ns_module_doc_string(w, ns);
        write_ns_module_method_table(w, members);
        write_ns_module_traverse_func(w, members);
        write_ns_module_clear_func(w, members);
        write_ns_module_def_struct(w, ns);
    }

    /**
     * Writes the namespace module PyMODINIT_FUNC function delecaration.
     */
    void write_namespace_module_init_function(
        writer& w, std::string_view const& ns, cache::namespace_members const& members)
    {
        w.write(
            "\nPyMODINIT_FUNC PyInit_%(void) noexcept\n{\n",
            bind<write_ns_module_name>(ns));
        {
            writer::indent_guard g{w};

            auto segments = get_dotted_name_segments(ns);
            w.write("using namespace py::cpp::%;\n\n", bind_list("::", segments));

            w.write("py::pyobj_handle module{PyModule_Create(&module_def)};\n\n");

            w.write("if (!module)\n{\n");
            {
                writer::indent_guard gg{w};

                w.write("return nullptr;\n");
            }
            w.write("}\n\n");

            w.write("auto object_type = py::get_python_type<py::Object>();\n");
            w.write("if (!object_type)\n{\n");
            {
                writer::indent_guard gg{w};

                w.write("return nullptr;\n");
            }
            w.write("}\n\n");

            w.write("py::pyobj_handle bases {PyTuple_Pack(1, object_type)};\n\n");

            w.write("if (!bases)\n{\n");
            {
                writer::indent_guard gg{w};

                w.write("return nullptr;\n");
            }
            w.write("}\n\n");

            w.write(
                "auto state = reinterpret_cast<module_state*>(PyModule_GetState(module.get()));\n");
            w.write("assert(state);\n\n");

            settings.filter.bind_each<write_ns_module_init_python_type>(
                members.classes)(w);
            settings.filter.bind_each<write_ns_module_init_python_type>(
                members.interfaces)(w);
            settings.filter.bind_each<write_ns_module_init_python_type>(
                members.structs)(w);
            w.write("\nreturn module.detach();\n");
        }
        w.write("}\n");
    }

    void write_winrt_type_name_constant(writer& w, TypeDef const& type)
    {
        w.write(
            "constexpr const char* const type_name_@ = \"@\";\n",
            type.TypeName(),
            type.TypeName());
    }

    void write_dealloc_function(writer& w, TypeDef const& type)
    {
        auto category = get_category(type);
        if (category == category::class_type && is_static_class(type))
        {
            return;
        }

        w.write(
            "\nstatic void _dealloc_@(%* self)\n{\n",
            type.TypeName(),
            bind<write_pywrapper_type>(type));

        if (category == category::class_type || category == category::interface_type)
        {
            writer::indent_guard g{w};

            auto format = R"(auto hash_value = %;
py::wrapped_instance(hash_value, nullptr);
self->obj%;
)";

            w.write(
                format,
                is_ptype(type)
                    ? "self->obj->hash()"
                    : "std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj)",
                is_ptype(type) ? ".reset()" : " = nullptr");
        }
        w.write("}\n");
    }

    void write_method_self_param(writer& w, TypeDef const& type, bool is_static)
    {
        if (is_static)
        {
            w.write("PyObject* /*unused*/");
        }
        else
        {
            w.write("%* self", bind<write_pywrapper_type>(type));
        }
    }

    void write_param_name(writer& w, method_signature::param_t param)
    {
        w.register_type_namespace(param.second->Type());
        w.write("param%", param.first.Sequence() - 1);
    }

    void write_out_param_init(writer& w, method_signature::param_t const& param)
    {
        call(
            get_type_semantics(param.second->Type()),
            [&](TypeDef const& type)
            {
                switch (get_category(type))
                {
                case category::class_type:
                case category::interface_type:
                case category::delegate_type:
                    w.write("nullptr");
                    break;
                }
            },
            [&](generic_type_instance const&)
            {
                w.write("nullptr");
            },
            [](auto)
            {
            });
    }

    void write_convert_to_params(writer& w, MethodDef const& method, int sequence)
    {
        switch (get_argument_convention(method))
        {
        case argument_convention::single_arg:
            w.write("arg");
            break;
        case argument_convention::variable_args:
            w.write("args, %", sequence);
            break;
        default:
            throw_invalid("write_convert_to_params");
        }
    }

    void write_method_param_definition(
        writer& w, MethodDef const& method, method_signature::param_t const& param)
    {
        auto sequence = param.first.Sequence() - 1;

        switch (get_param_category(param))
        {
        case param_category::in:
            w.write(
                "auto % = py::convert_to<%>(%);\n",
                bind<write_param_name>(param),
                param.second->Type(),
                bind<write_convert_to_params>(method, sequence));
            break;
        case param_category::out:
            w.write(
                "% % { % };\n",
                param.second->Type(),
                bind<write_param_name>(param),
                bind<write_out_param_init>(param));
            break;
        case param_category::pass_array:
            w.write(
                "auto % = py::convert_to<winrt::array_view<%>>(%);\n",
                bind<write_param_name>(param),
                param.second->Type(),
                bind<write_convert_to_params>(method, sequence));
            break;
        case param_category::fill_array:
            w.write(
                "auto %_count = py::convert_to<winrt::com_array<%>::size_type>(%);\n",
                bind<write_param_name>(param),
                param.second->Type(),
                bind<write_convert_to_params>(method, sequence));
            w.write(
                "winrt::com_array<%> % ( %_count, py::empty_instance<%>::get() );\n",
                param.second->Type(),
                bind<write_param_name>(param),
                bind<write_param_name>(param),
                param.second->Type());
            break;
        case param_category::receive_array:
            w.write(
                "winrt::com_array<%> % { };\n",
                param.second->Type(),
                bind<write_param_name>(param));
            break;
        default:
            throw_invalid("invalid param_category");
        }
    }

    void write_method_invoke_context(
        writer& w, TypeDef const& type, MethodDef const& method)
    {
        if (is_ptype(type))
        {
            w.write("_obj.");
        }
        else if (method && (is_static(method) || is_constructor(method)))
        {
            w.write("%::", type);
        }
        else
        {
            w.write("self->obj.");
        }
    }

    void write_method_cpp_name(writer& w, MethodDef const& method)
    {
        auto name = method.Name();

        if (method.SpecialName())
        {
            w.write(name.substr(name.find('_') + 1));
        }
        else
        {
            w.write(name);
        }
    }

    void write_get_param(writer& w, std::string const& paramName)
    {
        w.write("%.get()", paramName);
    }

    void write_detach_param(writer& w, std::string const& paramName)
    {
        w.write("%.detach()", paramName);
    }

    void write_py_tuple_pack(writer& w, std::vector<std::string> const& params)
    {
        w.write(
            "PyTuple_Pack(%, %)",
            static_cast<int>(params.size()),
            bind_list<write_get_param>(", ", params));
    }

    void write_method_body_contents(
        writer& w,
        TypeDef const& type,
        MethodDef const& method,
        bool put_property_method = false)
    {
        XLANG_ASSERT(!is_constructor(method));

        auto write_void_return
            = [](writer& w, MethodDef const& method, bool set_property_method)
        {
            // instance property set methods are projected as Python setters, thus
            // return 0 to indicate success static property set methods are projected as
            // normal Python methods that return None
            if (set_property_method && !is_static(method))
            {
                w.write("return 0;\n");
            }
            else
            {
                w.write("Py_RETURN_NONE;\n");
            }
        };

        method_signature signature{method};

        // convert in params from Python -> C++
        for (auto&& param : signature.params())
        {
            write_method_param_definition(w, method, param);
        }
        if (signature.params().size() > 0)
        {
            w.write("\n");
        }

        // Invoke member - simplified code path for methods w/ no out params
        if (count_out_param(signature.params()) == 0)
        {
            if (signature.return_signature())
            {
                w.register_type_namespace(signature.return_signature().Type());

                w.write(
                    "return py::convert(%%(%));\n",
                    bind<write_method_invoke_context>(type, method),
                    bind<write_method_cpp_name>(method),
                    bind_list<write_param_name>(", ", signature.params()));
            }
            else
            {
                w.write(
                    "%%(%);\n",
                    bind<write_method_invoke_context>(type, method),
                    bind<write_method_cpp_name>(method),
                    bind_list<write_param_name>(", ", signature.params()));

                write_void_return(w, method, put_property_method);
            }

            return;
        }

        // Invoke member - code path for methods w/ out params
        if (signature.return_signature())
        {
            w.register_type_namespace(signature.return_signature().Type());
            w.write("auto return_value = ");
        }
        w.write(
            "%%(%);\n",
            bind<write_method_invoke_context>(type, method),
            bind<write_method_cpp_name>(method),
            bind_list<write_param_name>(", ", signature.params()));

        w.write("\n");

        // Convert return values and out parameters from C++ -> Python
        std::vector<std::string> return_values{};
        if (signature.return_signature() || is_constructor(method))
        {
            auto format
                = R"(py::pyobj_handle out_return_value{ py::convert(return_value) };
if (!out_return_value)
{
    return nullptr;
}
)";
            w.write(format);
            return_values.push_back("out_return_value");
        }

        for (auto&& param : signature.params())
        {
            if (!is_out_param(param))
            {
                continue;
            }

            auto sequence = param.first.Sequence() - 1;
            auto out_param = w.write_temp("out%", sequence);

            auto format = R"(py::pyobj_handle %{ py::convert(param%) };
if (!%)
{
    return nullptr;
}
)";
            w.write(format, out_param, sequence, out_param);
            return_values.push_back(out_param);
        }

        // Return Python projected return/out params
        if (return_values.size() == 0)
        {
            write_void_return(w, method, put_property_method);
        }
        else if (return_values.size() == 1)
        {
            w.write("return %;\n", bind<write_detach_param>(return_values[0]));
        }
        else
        {
            w.write("return %;\n", bind<write_py_tuple_pack>(return_values));
        }
    }

    void write_class_new_function(writer& w, TypeDef const& type)
    {
        w.write(
            "\nstatic PyObject* _new_%(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept\n{\n",
            type.TypeName());

        {
            writer::indent_guard g{w};

            auto constructors = get_constructors(type);
            if (is_static_class(type) || constructors.size() == 0)
            {
                w.write(
                    "py::set_invalid_activation_error(type_name_@);\n",
                    type.TypeName());
                w.write("return nullptr;\n");
            }
            else
            {
                w.write(R"(if (kwds != nullptr)
{
    py::set_invalid_kwd_args_error();
    return nullptr;
}

Py_ssize_t arg_count = PyTuple_Size(args);
)");

                separator s{w, "else "};
                for (auto&& ctor : constructors)
                {
                    method_signature signature{ctor};

                    s();
                    w.write(
                        "if (arg_count == %)\n{\n", count_in_param(signature.params()));
                    {
                        writer::indent_guard g2{w};
                        write_try_catch(
                            w,
                            [&](writer& w)
                            {
                                for (auto&& param : signature.params())
                                {
                                    write_method_param_definition(w, ctor, param);
                                }

                                if (signature.params().size() > 0)
                                {
                                    w.write("\n");
                                }

                                w.write(
                                    "% instance{ % };\nreturn py::wrap(instance, type);\n",
                                    type,
                                    bind_list<write_param_name>(
                                        ", ", signature.params()));
                            });
                    }
                    w.write("}\n");
                }

                w.write(R"(else
{
    py::set_invalid_arg_count_error(arg_count);
    return nullptr;
}
)");
            }
        }
        w.write("}\n");
    }

    void write_new_function(writer& w, TypeDef const& type)
    {
        auto category = get_category(type);

        if (category == category::interface_type)
        {
            auto format = R"(
static PyObject* _new_@(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
{
    py::set_invalid_activation_error(type_name_@);
    return nullptr;
}
)";
            w.write(format, type.TypeName(), type.TypeName());
        }
        else if (category == category::class_type)
        {
            write_class_new_function(w, type);
        }
    }

    void write_method_overloads(
        writer& w, TypeDef const& type, std::string_view method_name)
    {
        w.write("Py_ssize_t arg_count = PyTuple_Size(args);\n\n");
        separator s{w, "else "};

        enumerate_methods(
            w,
            type,
            [&](auto const& method, bool is_overloaded)
            {
                if (method.Name() == method_name)
                {
                    method_signature signature{method};

                    s();
                    w.write(
                        "if (arg_count == %)\n{\n", count_in_param(signature.params()));
                    {
                        writer::indent_guard g{w};
                        write_try_catch(
                            w,
                            [&](writer& w)
                            {
                                write_method_body_contents(w, type, method);
                            });
                    }
                    w.write("}\n");
                }
            });

        w.write(R"(else
{
    py::set_invalid_arg_count_error(arg_count);
    return nullptr;
}
)");
    }

    void write_get_property_function(
        writer& w, TypeDef const& type, MethodDef const& method)
    {
        w.write(
            "\nstatic PyObject* @_%(%, void* /*unused*/) noexcept\n{\n",
            type.TypeName(),
            method.Name(),
            bind<write_method_self_param>(type, is_static(method)));
        {
            writer::indent_guard g{w};

            if (is_ptype(type))
            {
                w.write("return self->obj->%();\n", method.Name());
            }
            else
            {
                write_try_catch(
                    w,
                    [&](writer& w)
                    {
                        write_method_body_contents(w, type, method);
                    });
            }
        }
        w.write("}\n");
    }

    void write_put_property_function(
        writer& w, TypeDef const& type, MethodDef const& method)
    {
        if (!method)
            return;

        auto return_type = is_static(method) ? "PyObject*" : "int";

        w.write(
            "\nstatic % @_%(%, PyObject* arg, void* /*unused*/) noexcept\n{\n",
            return_type,
            type.TypeName(),
            method.Name(),
            bind<write_method_self_param>(type, is_static(method)));
        {
            writer::indent_guard g{w};
            if (is_ptype(type))
            {
                w.write("return self->obj->%(arg);\n", method.Name());
            }
            else
            {
                if (is_static(method))
                {
                    write_try_catch(
                        w,
                        [&](writer& w)
                        {
                            write_method_body_contents(w, type, method, true);
                        });
                }
                else
                {
                    write_setter_try_catch(
                        w,
                        [&](writer& w)
                        {
                            write_method_body_contents(w, type, method, true);
                        });
                }
            }
        }
        w.write("}\n");
    }

    void write_event_function(writer& w, TypeDef const& type, MethodDef const& method)
    {
        w.write(
            "\nstatic PyObject* @_%(%, PyObject* arg) noexcept\n{\n",
            type.TypeName(),
            method.Name(),
            bind<write_method_self_param>(type, is_static(method)));
        {
            writer::indent_guard g{w};
            if (is_ptype(type))
            {
                w.write("return self->obj->%(arg);\n", method.Name());
            }
            else
            {
                write_try_catch(
                    w,
                    [&](writer& w)
                    {
                        write_method_body_contents(w, type, method);
                    });
            }
        }
        w.write("}\n");
    }

    void write_dunder_iter_body(writer& w, TypeDef const& type)
    {
        if (implements_iiterable(type))
        {
            write_try_catch(
                w,
                [&](writer& w)
                {
                    w.write(
                        "return py::convert(%First());\n",
                        bind<write_method_invoke_context>(type, MethodDef{}));
                });
        }
        else if (implements_iiterator(type))
        {
            XLANG_ASSERT(!implements_iiterable(type));
            w.write(
                "return reinterpret_cast<PyObject*>(%);\n",
                is_ptype(type) ? "this" : "self");
        }
        else
        {
            XLANG_ASSERT(false);
        }
    }

    void write_dunder_iter_next_body(writer& w, TypeDef const& type)
    {
        write_try_catch(
            w,
            [&](writer& w)
            {
                auto format = R"(if (%HasCurrent())
{
    auto cur = %Current();
    %MoveNext();
    return py::convert(cur);
}
else
{
    return nullptr;
})";
                w.write(
                    format,
                    bind<write_method_invoke_context>(type, MethodDef{}),
                    bind<write_method_invoke_context>(type, MethodDef{}),
                    bind<write_method_invoke_context>(type, MethodDef{}));
            },
            "nullptr");
    }

    void write_seq_length_body(writer& w, TypeDef const& type)
    {
        write_try_catch(
            w,
            [&](writer& w)
            {
                w.write(
                    "return static_cast<Py_ssize_t>(%Size());\n",
                    bind<write_method_invoke_context>(type, MethodDef{}));
            },
            "-1");
    }

    void write_seq_item_body(writer& w, TypeDef const& type)
    {
        write_try_catch(
            w,
            [&](writer& w)
            {
                w.write(
                    "return py::convert(%GetAt(static_cast<uint32_t>(i)));\n",
                    bind<write_method_invoke_context>(type, MethodDef{}));
            });
    }

    void write_seq_assign_body(writer& w, TypeDef const& type)
    {
        std::string collection_type{};
        enumerate_methods(
            w,
            type,
            [&](MethodDef const& method, bool is_overloaded)
            {
                if (method.Name() == "GetAt")
                {
                    collection_type
                        = w.write_temp("%", method.Signature().ReturnType().Type());
                }
            });

        write_try_catch(
            w,
            [&](writer& w)
            {
                w.write(
                    R"(if (value == nullptr) { %RemoveAt(static_cast<uint32_t>(i)); }
else { %SetAt(static_cast<uint32_t>(i), py::convert_to<%>(value)); }
return 0;
)",
                    bind<write_method_invoke_context>(type, MethodDef{}),
                    bind<write_method_invoke_context>(type, MethodDef{}),
                    collection_type);
            },
            "-1");
    }

    void write_map_contains_body(writer& w, TypeDef const& type)
    {
        std::string key_type{};
        enumerate_methods(
            w,
            type,
            [&](MethodDef const& method, bool is_overloaded)
            {
                if (method.Name() == "HasKey")
                {
                    method_signature signature{method};
                    key_type
                        = w.write_temp("%", signature.params().at(0).second->Type());
                }
            });

        write_try_catch(
            w,
            [&](writer& w)
            {
                w.write(
                    "return static_cast<int>(%HasKey(py::convert_to<%>(key)));\n",
                    bind<write_method_invoke_context>(type, MethodDef{}),
                    key_type);
            },
            "-1");
    }

    void write_map_length_body(writer& w, TypeDef const& type)
    {
        write_try_catch(
            w,
            [&](writer& w)
            {
                w.write(
                    "return static_cast<Py_ssize_t>(%Size());\n",
                    bind<write_method_invoke_context>(type, MethodDef{}));
            },
            "-1");
    }

    void write_map_subscript_body(writer& w, TypeDef const& type)
    {
        std::string key_type{};
        enumerate_methods(
            w,
            type,
            [&](MethodDef const& method, bool is_overloaded)
            {
                if (method.Name() == "Lookup")
                {
                    method_signature signature{method};
                    key_type
                        = w.write_temp("%", signature.params().at(0).second->Type());
                }
            });

        write_try_catch(
            w,
            [&](writer& w)
            {
                w.write(
                    "return py::convert(%Lookup(py::convert_to<%>(key)));\n",
                    bind<write_method_invoke_context>(type, MethodDef{}),
                    key_type);
            });
    }

    void write_map_assign_body(writer& w, TypeDef const& type)
    {
        std::string key_type, value_type{};
        enumerate_methods(
            w,
            type,
            [&](MethodDef const& method, bool is_overloaded)
            {
                if (method.Name() == "Lookup")
                {
                    method_signature signature{method};
                    key_type
                        = w.write_temp("%", signature.params().at(0).second->Type());
                    value_type = w.write_temp("%", signature.return_signature().Type());
                }
            });

        write_try_catch(
            w,
            [&](writer& w)
            {
                auto format = R"(auto _key = py::convert_to<%>(key);
if (value == nullptr) { %Remove(_key); }
else { %Insert(_key, py::convert_to<%>(value)); }
return 0;
)";
                w.write(
                    format,
                    key_type,
                    bind<write_method_invoke_context>(type, MethodDef{}),
                    bind<write_method_invoke_context>(type, MethodDef{}),
                    value_type);
            },
            "-1");
    }

    void write_method_functions(writer& w, TypeDef const& type)
    {
        // create a map of methods to determine overloads + ensure all overloads match
        // instance/static
        std::map<std::string_view, bool> method_map{};
        enumerate_methods(
            w,
            type,
            [&](auto const& method, bool is_overloaded)
            {
                XLANG_ASSERT(
                    contains(method_map, method.Name())
                        ? method_map[method.Name()] == is_static(method)
                        : true);
                method_map[method.Name()] = is_static(method);
            });

        for (auto&& [method_name, method_is_static] : method_map)
        {
            w.write(
                "\nstatic PyObject* @_%(%, PyObject* args) noexcept\n{\n",
                type.TypeName(),
                method_name,
                bind<write_method_self_param>(type, method_is_static));
            {
                writer::indent_guard g{w};

                if (is_ptype(type))
                {
                    w.write("return self->obj->%(args);\n", method_name);
                }
                else
                {
                    write_method_overloads(w, type, method_name);
                }
            }
            w.write("}\n");
        }

        enumerate_properties(
            w,
            type,
            [&](auto const& prop)
            {
                auto&& [get_method, put_method] = get_property_methods(prop);
                write_get_property_function(w, type, get_method);
                write_put_property_function(w, type, put_method);
            });

        enumerate_events(
            w,
            type,
            [&](auto const& evt)
            {
                auto&& [add_method, remove_method] = get_event_methods(evt);
                write_event_function(w, type, add_method);
                write_event_function(w, type, remove_method);
            });

        if (!(is_ptype(type) || is_static_class(type)))
        {
            w.write(
                "\nstatic PyObject* _from_@(PyObject* /*unused*/, PyObject* arg) noexcept\n{\n",
                type.TypeName());
            {
                writer::indent_guard g{w};
                write_try_catch(
                    w,
                    [&](writer& w)
                    {
                        auto format
                            = "auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);\nreturn "
                              "py::convert(return_value.as<%>());\n";
                        w.write(format, type);
                    });
            }
            w.write("}\n");
        }

        if (implements_iclosable(type))
        {
            w.write(
                "\nstatic PyObject* _enter_@(%* self) noexcept\n",
                type.TypeName(),
                bind<write_pywrapper_type>(type));
            w.write("{\n");
            {
                writer::indent_guard g{w};
                w.write("Py_INCREF(self);\n");
                w.write("return reinterpret_cast<PyObject*>(self);\n");
            }
            w.write("}\n");

            w.write(
                "\nstatic PyObject* _exit_@(%* self) noexcept\n",
                type.TypeName(),
                bind<write_pywrapper_type>(type));
            w.write("{\n");
            {
                writer::indent_guard g{w};
                write_try_catch(
                    w,
                    [](auto& w)
                    {
                        w.write("self->obj.Close();\n");
                        w.write("Py_RETURN_FALSE;\n");
                    });
            }
            w.write("}\n");
        }

        if (implements_ibuffer(type) || implements_imemorybufferreference(type))
        {
            w.write(
                "\nstatic int _get_buffer_@(%* self, Py_buffer* view, int flags) noexcept\n{\n",
                type.TypeName(),
                bind<write_pywrapper_type>(type));
            {
                writer::indent_guard g{w};
                w.write("try\n");
                w.write("{\n");
                {
                    writer::indent_guard gg{w};
                    w.write(
                        "return PyBuffer_FillInfo(view, reinterpret_cast<PyObject*>(self), "
                        "reinterpret_cast<void*>(self->obj.data()), static_cast<Py_ssize_t>(self->obj.@()), 0, flags);\n",
                        implements_ibuffer(type) ? "Length" : "Capacity");
                }
                w.write("}\n");
                w.write("catch (...)\n");
                w.write("{\n");
                {
                    writer::indent_guard gg{w};
                    w.write("view->obj = nullptr;\n");
                    // TODO: attach C++ exception info to Python exception
                    w.write("PyErr_SetNone(PyExc_BufferError);\n");
                    w.write("return -1;\n");
                }
                w.write("}\n");
            }
            w.write("}\n");

            // workaround for https://bugs.python.org/issue40724
            w.write("\n#if PY_VERSION_HEX < 0x03090000\n");
            w.write(
                "static PyBufferProcs _PyBufferProcs_@ = { reinterpret_cast<getbufferproc>(_get_buffer_@), "
                "reinterpret_cast<releasebufferproc>(nullptr) };\n",
                type.TypeName(),
                type.TypeName());
            w.write("#endif\n");
        }

        if (implements_istringable(type))
        {
            w.write(
                "\nstatic PyObject* _str_@(%* self) noexcept\n{\n",
                type.TypeName(),
                bind<write_pywrapper_type>(type));
            {
                writer::indent_guard g{w};
                write_try_catch(
                    w,
                    [](auto& w)
                    {
                        w.write("return py::convert(self->obj.ToString());\n");
                    });
            }
            w.write("}\n");
        }

        auto write_ptype_body = [&](std::string_view ptype_func_call,
                                    std::function<void(writer&)> ctype_func)
        {
            writer::indent_guard g{w};

            if (is_ptype(type))
            {
                w.write("return self->obj->%;\n", ptype_func_call);
            }
            else
            {
                ctype_func(w);
            }
        };

        if (implements_iasync(type))
        {
            w.write(
                "\nstatic PyObject* _await_@(%* self) noexcept\n{\n",
                type.TypeName(),
                bind<write_pywrapper_type>(type));
            {
                write_ptype_body(
                    "dunder_await()",
                    [&](auto& w)
                    {
                        w.write("return py::dunder_await(self->obj);\n");
                    });
            }
            w.write("}\n");
        }

        if (implements_iiterable(type) || implements_iiterator(type))
        {
            w.write(
                "\nstatic PyObject* _iterator_@(%* self) noexcept\n{\n",
                type.TypeName(),
                bind<write_pywrapper_type>(type));
            {
                write_ptype_body(
                    "dunder_iter()",
                    [&](auto& w)
                    {
                        write_dunder_iter_body(w, type);
                    });
            }
            w.write("}\n");
        }

        if (implements_iiterator(type))
        {
            w.write(
                "\nstatic PyObject* _iterator_next_@(%* self) noexcept\n{\n",
                type.TypeName(),
                bind<write_pywrapper_type>(type));
            {
                write_ptype_body(
                    "dunder_iternext()",
                    [&](auto& w)
                    {
                        write_dunder_iter_next_body(w, type);
                    });
            }
            w.write("}\n");
        }

        if (implements_sequence(type))
        {
            w.write(
                "\nstatic Py_ssize_t _seq_length_@(%* self) noexcept\n{\n",
                type.TypeName(),
                bind<write_pywrapper_type>(type));
            {
                write_ptype_body(
                    "seq_length()",
                    [&](auto& w)
                    {
                        write_seq_length_body(w, type);
                    });
            }
            w.write("}\n");

            w.write(
                "\nstatic PyObject* _seq_item_@(%* self, Py_ssize_t i) noexcept\n{\n",
                type.TypeName(),
                bind<write_pywrapper_type>(type));
            {
                write_ptype_body(
                    "seq_item(i)",
                    [&](auto& w)
                    {
                        write_seq_item_body(w, type);
                    });
            }
            w.write("}\n");

            if (implements_ivector(type))
            {
                w.write(
                    "\nstatic int _seq_assign_@(%* self, Py_ssize_t i, PyObject* value) noexcept\n{\n",
                    type.TypeName(),
                    bind<write_pywrapper_type>(type));
                {
                    write_ptype_body(
                        "seq_assign(i, value)",
                        [&](auto& w)
                        {
                            write_seq_assign_body(w, type);
                        });
                }
                w.write("}\n");
            }
        }

        if (implements_mapping(type))
        {
            w.write(
                "\nstatic int _map_contains_@(%* self, PyObject* key) noexcept\n{\n",
                type.TypeName(),
                bind<write_pywrapper_type>(type));
            {
                write_ptype_body(
                    "map_contains(key)",
                    [&](auto& w)
                    {
                        write_map_contains_body(w, type);
                    });
            }
            w.write("}\n");

            w.write(
                "\nstatic Py_ssize_t _map_length_@(%* self) noexcept\n{\n",
                type.TypeName(),
                bind<write_pywrapper_type>(type));
            {
                write_ptype_body(
                    "map_length()",
                    [&](auto& w)
                    {
                        write_map_length_body(w, type);
                    });
            }
            w.write("}\n");

            w.write(
                "\nstatic PyObject* _map_subscript_@(%* self, PyObject* key) noexcept\n{\n",
                type.TypeName(),
                bind<write_pywrapper_type>(type));
            {
                write_ptype_body(
                    "map_subscript(key)",
                    [&](auto& w)
                    {
                        write_map_subscript_body(w, type);
                    });
            }
            w.write("}\n");

            if (implements_imap(type))
            {
                w.write(
                    "\nstatic int _map_assign_@(%* self, PyObject* key, PyObject* value) noexcept\n{\n",
                    type.TypeName(),
                    bind<write_pywrapper_type>(type));
                {
                    write_ptype_body(
                        "map_assign(key, value)",
                        [&](auto& w)
                        {
                            write_map_assign_body(w, type);
                        });
                }
                w.write("}\n");
            }
        }
    }

    void write_method_table(writer& w, TypeDef const& type)
    {
        auto get_argument_convention_flag = [](MethodDef const& method)
        {
            switch (get_argument_convention(method))
            {
            case argument_convention::no_args:
                return "METH_NOARGS";
            case argument_convention::single_arg:
                return "METH_O";
            case argument_convention::variable_args:
                return "METH_VARARGS";
            }

            throw_invalid("invalid argument_convention");
        };

        auto write_row = [&](MethodDef const& method)
        {
            auto argument_convention_flag = get_argument_convention_flag(method);
            auto static_flag
                = is_static(method) || is_constructor(method) ? " | METH_STATIC" : "";

            w.write(
                "{ \"%\", reinterpret_cast<PyCFunction>(@_%), %%, nullptr },\n",
                bind<write_lower_snake_case_python_identifier>(method.Name()),
                type.TypeName(),
                method.Name(),
                argument_convention_flag,
                static_flag);
        };

        w.write("\nstatic PyMethodDef _methods_@[] = {\n", type.TypeName());
        {
            writer::indent_guard g{w};

            std::set<std::string_view> method_names{};
            enumerate_methods(
                w,
                type,
                [&](auto const& method, bool is_overloaded)
                {
                    if (!contains(method_names, method.Name()))
                    {
                        write_row(method);
                    }

                    method_names.insert(method.Name());
                });

            enumerate_properties(
                w,
                type,
                [&](auto const& prop)
                {
                    auto [get_method, put_method] = get_property_methods(prop);
                    // instance properties are listed in the getset table, not the
                    // method table
                    if (is_static(get_method))
                    {
                        write_row(get_method);
                        if (put_method)
                        {
                            write_row(put_method);
                        }
                    }
                });

            enumerate_events(
                w,
                type,
                [&](auto const& evt)
                {
                    auto [add_method, remove_method] = get_event_methods(evt);
                    write_row(add_method);
                    write_row(remove_method);
                });

            // TODO: support _from for ptypes
            if (!(is_ptype(type) || is_static_class(type)))
            {
                w.write(
                    "{ \"_from\", reinterpret_cast<PyCFunction>(_from_@), METH_O | METH_STATIC, nullptr },\n",
                    type.TypeName());
            }

            if (implements_iclosable(type))
            {
                w.write(
                    "{ \"__enter__\", reinterpret_cast<PyCFunction>(_enter_@), METH_NOARGS, nullptr },\n",
                    type.TypeName());
                w.write(
                    "{ \"__exit__\",  reinterpret_cast<PyCFunction>(_exit_@), METH_VARARGS, nullptr },\n",
                    type.TypeName());
            }

            if (is_ptype(type))
            {
                w.write("#if PY_VERSION_HEX >= 0x03090000\n");
                w.write(
                    "{ \"__class_getitem__\", Py_GenericAlias, METH_O | METH_CLASS, PyDoc_STR(\"See PEP 585\") },\n");
                w.write("#endif\n");
            }

            w.write("{ }\n");
        }

        w.write("};\n");
    }

    void write_getset_table(writer& w, TypeDef const& type)
    {
        auto write_row = [&](std::string_view field_name,
                             std::string_view getter_name,
                             std::string_view setter_name)
        {
            auto setter = setter_name.empty() ? "nullptr"
                                              : w.write_temp(
                                                  "reinterpret_cast<setter>(@_%)",
                                                  type.TypeName(),
                                                  setter_name);

            w.write(
                "{ \"%\", reinterpret_cast<getter>(@_%), %, nullptr, nullptr },\n",
                bind<write_lower_snake_case_python_identifier>(field_name),
                type.TypeName(),
                getter_name,
                setter);
        };

        w.write("\nstatic PyGetSetDef _getset_@[] = {\n", type.TypeName());
        {
            writer::indent_guard g{w};

            auto category = get_category(type);
            if (category == category::struct_type)
            {
                for (auto&& field : type.FieldList())
                {
                    write_row(
                        field.Name(),
                        w.write_temp("get_%", field.Name()),
                        w.write_temp("set_%", field.Name()));
                }
            }
            else if (
                category == category::class_type
                || category == category::interface_type)
            {
                enumerate_properties(
                    w,
                    type,
                    [&](Property prop)
                    {
                        auto [getter, setter] = get_property_methods(prop);

                        // static properties are listed in the method table, not the
                        // getset table
                        if (!is_static(getter))
                        {
                            write_row(
                                prop.Name(),
                                getter.Name(),
                                setter ? setter.Name() : "");
                        }
                    });
            }
            w.write("{ }\n");
        }
        w.write("};\n");
    }

    void write_type_slot_table(writer& w, TypeDef const& type)
    {
        auto category = get_category(type);
        auto name = type.TypeName();

        w.write("\nstatic PyType_Slot _type_slots_@[] = \n{\n", name);

        {
            writer::indent_guard g{w};

            w.write("{ Py_tp_new, _new_@ },\n", name);
            if (!is_static_class(type))
            {
                w.write("{ Py_tp_dealloc, _dealloc_@ },\n", name);
            }
            if ((category == category::class_type)
                || (category == category::interface_type))
            {
                w.write("{ Py_tp_methods, _methods_@ },\n", name);
            }
            w.write("{ Py_tp_getset, _getset_@ },\n", name);

            if (implements_ibuffer(type) || implements_imemorybufferreference(type))
            {
                // this slot was enabled in 3.9 - https://bugs.python.org/issue40724
                w.write("#if PY_VERSION_HEX >= 0x03090000\n");
                w.write("{ Py_bf_getbuffer, _get_buffer_@ },\n", name);
                w.write("#endif\n");
            }

            if (implements_istringable(type))
            {
                w.write("{ Py_tp_str, _str_@ },\n", name);
            }
            if (implements_iasync(type))
            {
                w.write(
                    "{ Py_am_await, reinterpret_cast<unaryfunc>(_await_@) },\n", name);
            }
            if (implements_iiterable(type) || implements_iiterator(type))
            {
                w.write("{ Py_tp_iter, _iterator_@ },\n", name);
            }
            if (implements_iiterator(type))
            {
                w.write("{ Py_tp_iternext, _iterator_next_@ },\n", name);
            }
            if (implements_sequence(type))
            {
                w.write("{ Py_sq_length, _seq_length_@ },\n", name);
                w.write("{ Py_sq_item, _seq_item_@ },\n", name);

                if (implements_ivector(type))
                {
                    w.write("{ Py_sq_ass_item, _seq_assign_@ },\n", name);
                }
            }
            if (implements_mapping(type))
            {
                w.write("{ Py_sq_contains, _map_contains_@ },\n", name);
                w.write("{ Py_mp_length, _map_length_@ },\n", name);
                w.write("{ Py_mp_subscript, _map_subscript_@ },\n", name);

                if (implements_imap(type))
                {
                    w.write("{ Py_mp_ass_subscript, _map_assign_@ },\n", name);
                }
            }
            w.write("{ },\n");
        }
        w.write("};\n");
    }

    void write_type_spec(writer& w, TypeDef const& type)
    {
        auto type_size
            = is_static_class(type)
                  ? "0"
                  : w.write_temp("sizeof(%)", bind<write_pywrapper_type>(type));

        auto format = R"(
static PyType_Spec type_spec_@ =
{
    "%.@",
    %,
    0,
    Py_TPFLAGS_DEFAULT,
    _type_slots_@
};
)";
        auto type_name = type.TypeName();
        w.write(
            format,
            type_name,
            bind<write_ns_module_name>(type.TypeNamespace()),
            type_name,
            type_size,
            type_name);
    }

    void write_category(writer& w, TypeDef const& type)
    {
        switch (get_category(type))
        {
        case category::class_type:
            w.write("class");
            break;
        case category::delegate_type:
            w.write("delegate");
            break;
        case category::enum_type:
            w.write("enum");
            break;
        case category::interface_type:
            w.write("interface");
            break;
        case category::struct_type:
            w.write("struct");
            break;
        }
    }

    /**
     * Writes an pure Python type registration method.
     */
    void write_py_type_registration_method(writer& w, TypeDef const& type)
    {
        w.write(
            "\nstatic PyObject* register_%(PyObject* module, PyObject* type)\n{\n",
            type.TypeName());
        {
            writer::indent_guard g{w};

            w.write(
                "auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));\n");

            w.write("assert(state);\n\n");

            w.write("if (state->type_@)\n{\n", type.TypeName());
            {
                writer::indent_guard gg{w};

                w.write(
                    "PyErr_SetString(PyExc_RuntimeError, \"type has already been registered\");\n");
                w.write("return nullptr;\n");
            }
            w.write("}\n\n");

            w.write("if (!PyType_Check(type))\n{\n");
            {
                writer::indent_guard gg{w};

                w.write(
                    "PyErr_SetString(PyExc_TypeError, \"argument is not a type\");\n");
                w.write("return nullptr;\n");
            }
            w.write("}\n\n");

            w.write("state->type_@ = type;\n", type.TypeName());
            w.write("Py_INCREF(state->type_@);\n\n", type.TypeName());

            w.write("\nPy_RETURN_NONE;\n");
        }
        w.write("}\n");
    }

    void write_inspectable_type(writer& w, TypeDef const& type)
    {
        if (is_exclusive_to(type))
            return;

        auto guard{w.push_generic_params(type.GenericParam())};

        w.write(
            "\n// ----- @ % --------------------\n",
            type.TypeName(),
            bind<write_category>(type));
        write_winrt_type_name_constant(w, type);
        write_new_function(w, type);
        write_dealloc_function(w, type);
        write_method_functions(w, type);
        write_method_table(w, type);
        write_getset_table(w, type);
        write_type_slot_table(w, type);
        write_type_spec(w, type);
    }

#pragma region pinterface functions
    void write_pinterface_type_mapper(writer& w, TypeDef const& type)
    {
        if (!is_ptype(type))
            return;

        auto format = R"(template <%>
struct pinterface_python_type<%<%>>
{
    using abstract = %;
    using concrete = %<%>;
};

)";
        w.write(
            format,
            bind_list<write_template_arg>(", ", type.GenericParam()),
            type,
            bind_list<write_template_arg_name>(", ", type.GenericParam()),
            bind<write_pyproj_type>(type),
            bind<write_pyimpl_type>(type),
            bind_list<write_template_arg_name>(", ", type.GenericParam()));
    }

    void write_pinterface_decl(writer& w, TypeDef const& type)
    {
        if (!is_ptype(type))
            return;

        auto guard{w.push_generic_params(type.GenericParam())};

        w.write("\nstruct @\n{\n", type.TypeName());
        {
            writer::indent_guard g{w};

            w.write("virtual ~@() {};\n", type.TypeName());
            w.write(
                "virtual winrt::Windows::Foundation::IUnknown const& get_unknown() noexcept = 0;\n");
            w.write("virtual std::size_t hash() noexcept = 0;\n");

            std::set<std::string_view> method_names{};
            enumerate_methods(
                w,
                type,
                [&](auto const& method, bool is_overloaded)
                {
                    if (!contains(method_names, method.Name()))
                    {
                        w.write(
                            "virtual PyObject* %(PyObject*) noexcept = 0;\n",
                            method.Name());
                    }

                    method_names.insert(method.Name());
                });

            enumerate_properties(
                w,
                type,
                [&](auto const& prop)
                {
                    auto [get_method, put_method] = get_property_methods(prop);
                    w.write("virtual PyObject* %() noexcept = 0;\n", get_method.Name());
                    if (put_method)
                    {
                        w.write(
                            "virtual int %(PyObject*) noexcept = 0;\n",
                            put_method.Name());
                    }
                });

            enumerate_events(
                w,
                type,
                [&](auto const& evt)
                {
                    auto [add_method, remove_method] = get_event_methods(evt);
                    w.write(
                        "virtual PyObject* %(PyObject*) noexcept = 0;\n",
                        add_method.Name());
                    w.write(
                        "virtual PyObject* %(PyObject*) noexcept = 0;\n",
                        remove_method.Name());
                });

            if (implements_iasync(type))
            {
                w.write("virtual PyObject* dunder_await() noexcept = 0;\n");
            }

            if (implements_iiterable(type) || implements_iiterator(type))
            {
                w.write("virtual PyObject* dunder_iter() noexcept = 0;\n");
            }

            if (implements_iiterator(type))
            {
                w.write("virtual PyObject* dunder_iternext() noexcept = 0;\n");
            }

            if (implements_sequence(type))
            {
                w.write("virtual Py_ssize_t seq_length() noexcept = 0;\n");
                w.write("virtual PyObject* seq_item(Py_ssize_t i) noexcept = 0;\n");

                if (implements_ivector(type))
                {
                    w.write(
                        "virtual int seq_assign(Py_ssize_t i, PyObject* value) noexcept = 0;\n");
                }
            }

            if (implements_mapping(type))
            {
                w.write("virtual int map_contains(PyObject* key) noexcept = 0;\n");
                w.write("virtual Py_ssize_t map_length() noexcept = 0;\n");
                w.write(
                    "virtual PyObject* map_subscript(PyObject* key) noexcept = 0;\n");

                if (implements_imap(type))
                {
                    w.write(
                        "virtual int map_assign(PyObject* key, PyObject* value) noexcept = 0;\n");
                }
            }
        }
        w.write("};\n");
    }

    void write_pinterface_impl(writer& w, TypeDef const& type)
    {
        if (!is_ptype(type))
            return;

        auto guard{w.push_generic_params(type.GenericParam())};

        w.write(
            "\ntemplate<%>\nstruct @ : public py::proj::%::@\n{\n",
            bind_list<write_template_arg>(", ", type.GenericParam()),
            type.TypeName(),
            bind<write_type_namespace>(type),
            type.TypeName());

        {
            writer::indent_guard g{w};

            w.write(
                "@(%<%> o) : _obj(o) {}\n",
                type.TypeName(),
                type,
                bind_list<write_template_arg_name>(", ", type.GenericParam()));
            w.write(
                "winrt::Windows::Foundation::IUnknown const& get_unknown() noexcept override { return _obj; }\n");
            w.write(
                "std::size_t hash() noexcept override { return py::get_instance_hash(_obj); }\n");

            std::set<std::string_view> method_names{};
            enumerate_methods(
                w,
                type,
                [&](auto const& method, bool is_overloaded)
                {
                    method_names.insert(method.Name());
                });

            for (auto&& method_name : method_names)
            {
                w.write(
                    "PyObject* %(PyObject* args) noexcept override\n{\n", method_name);
                {
                    writer::indent_guard gg{w};
                    write_method_overloads(w, type, method_name);
                }
                w.write("}\n");
            }

            enumerate_properties(
                w,
                type,
                [&](auto const& prop)
                {
                    auto methods = get_property_methods(prop);
                    auto get_method = std::get<0>(methods);
                    auto put_method = std::get<1>(methods);

                    w.write("PyObject* %() noexcept override\n{\n", get_method.Name());
                    {
                        writer::indent_guard gg{w};
                        write_try_catch(
                            w,
                            [&](writer& w)
                            {
                                write_method_body_contents(w, type, get_method);
                            });
                    }
                    w.write("}\n");

                    if (put_method)
                    {
                        w.write(
                            "int %(PyObject* arg) noexcept override\n{\n",
                            put_method.Name());
                        {
                            writer::indent_guard gg{w};
                            write_setter_try_catch(
                                w,
                                [&](writer& w)
                                {
                                    write_method_body_contents(
                                        w, type, put_method, true);
                                });
                        }
                        w.write("}\n");
                    }
                });

            enumerate_events(
                w,
                type,
                [&](auto const& evt)
                {
                    auto methods = get_event_methods(evt);
                    auto add_method = std::get<0>(methods);
                    auto remove_method = std::get<1>(methods);

                    w.write(
                        "PyObject* %(PyObject* arg) noexcept override\n{\n",
                        add_method.Name());
                    {
                        writer::indent_guard gg{w};
                        write_try_catch(
                            w,
                            [&](writer& w)
                            {
                                write_method_body_contents(w, type, add_method);
                            });
                    }
                    w.write("}\n");

                    w.write(
                        "PyObject* %(PyObject* arg) noexcept override\n{\n",
                        remove_method.Name());
                    {
                        writer::indent_guard gg{w};
                        write_try_catch(
                            w,
                            [&](writer& w)
                            {
                                write_method_body_contents(w, type, remove_method);
                            });
                    }
                    w.write("}\n");
                });

            if (implements_iasync(type))
            {
                w.write(
                    "PyObject* dunder_await() noexcept override { return py::dunder_await(_obj); }\n");
            }

            if (implements_iiterable(type) || implements_iiterator(type))
            {
                w.write("PyObject* dunder_iter() noexcept override\n{\n");
                {
                    writer::indent_guard gg{w};
                    write_dunder_iter_body(w, type);
                }
                w.write("}\n");
            }

            if (implements_iiterator(type))
            {
                w.write("PyObject* dunder_iternext() noexcept override\n{\n");
                {
                    writer::indent_guard gg{w};
                    write_dunder_iter_next_body(w, type);
                }
                w.write("}\n");
            }

            if (implements_sequence(type))
            {
                w.write("Py_ssize_t seq_length() noexcept override\n{\n");
                {
                    writer::indent_guard gg{w};
                    write_seq_length_body(w, type);
                }
                w.write("}\n");

                w.write("PyObject* seq_item(Py_ssize_t i) noexcept override\n{\n");
                {
                    writer::indent_guard gg{w};
                    write_seq_item_body(w, type);
                }
                w.write("}\n");

                if (implements_ivector(type))
                {
                    w.write(
                        "int seq_assign(Py_ssize_t i, PyObject* value) noexcept override\n{\n");
                    {
                        writer::indent_guard gg{w};
                        write_seq_assign_body(w, type);
                    }
                    w.write("}\n");
                }
            }

            if (implements_mapping(type))
            {
                w.write("int map_contains(PyObject* key) noexcept override\n{\n");
                {
                    writer::indent_guard gg{w};
                    write_map_contains_body(w, type);
                }
                w.write("}\n");

                w.write("Py_ssize_t map_length() noexcept override\n{\n");
                {
                    writer::indent_guard gg{w};
                    write_map_length_body(w, type);
                }
                w.write("}\n");

                w.write(
                    "PyObject* map_subscript(PyObject* key) noexcept override\n{\n");
                {
                    writer::indent_guard gg{w};
                    write_map_subscript_body(w, type);
                }
                w.write("}\n");

                if (implements_imap(type))
                {
                    w.write(
                        "int map_assign(PyObject* key, PyObject* value) noexcept override\n{\n");
                    {
                        writer::indent_guard gg{w};
                        write_map_assign_body(w, type);
                    }
                    w.write("}\n");
                }
            }

            w.write(
                "\n%<%> _obj{ nullptr };\n",
                type,
                bind_list<write_template_arg_name>(", ", type.GenericParam()));
        }
        w.write("};\n");
    }
#pragma endregion

#pragma region struct functions

    void write_struct_converter_decl(writer& w, TypeDef const& type)
    {
        auto ns = type.TypeNamespace();
        auto name = type.TypeName();
        if ((ns == "Windows.Foundation") && (name == "EventRegistrationToken"))
        {
            // The declaration for event_token is baked into pybase.h to address
            // ordering issues.
            return;
        }

        w.write("template<>\nstruct converter<%>\n{\n", type);
        {
            writer::indent_guard g{w};
            w.write(
                "static PyObject* convert(% instance) noexcept;\nstatic % convert_to(PyObject* obj);\n",
                type,
                type);
        }

        w.write("};\n\n");
    }

    void write_struct_field_var_type(writer& w, Field const& field)
    {
        call(
            get_struct_field_semantics(field, true),
            [&](fundamental_type type)
            {
                switch (type)
                {
                case fundamental_type::Boolean:
                    w.write("bool");
                    break;
                case fundamental_type::Char:
                    w.write("char16_t");
                    break;
                case fundamental_type::Int8:
                    w.write("int8_t");
                    break;
                case fundamental_type::UInt8:
                    w.write("uint8_t");
                    break;
                case fundamental_type::Int16:
                    w.write("int16_t");
                    break;
                case fundamental_type::UInt16:
                    w.write("uint16_t");
                    break;
                case fundamental_type::Int32:
                    w.write("int32_t");
                    break;
                case fundamental_type::UInt32:
                    w.write("uint32_t");
                    break;
                case fundamental_type::Int64:
                    w.write("int64_t");
                    break;
                case fundamental_type::UInt64:
                    w.write("uint64_t");
                    break;
                case fundamental_type::Float:
                    w.write("float");
                    break;
                case fundamental_type::Double:
                    w.write("double");
                    break;
                case fundamental_type::String:
                    w.write("winrt::hstring");
                    break;
                default:
                    throw_invalid("invalid fundamental type");
                }
            },
            [&]([[maybe_unused]] TypeDef const& type)
            {
                XLANG_ASSERT(get_category(type) == category::struct_type);
                w.write("PyObject*");
            },
            [](auto)
            {
                throw_invalid("invalid struct field type");
            });
    }

    /**
     * Writes the Python type name for a struct field.
     * @param [in]  w       The writer.
     * @param [in]  field   The field metadata.
     */
    void write_struct_field_python_type(writer& w, Field const& field)
    {
        call(
            get_struct_field_semantics(field, false),
            [&](fundamental_type type)
            {
                switch (type)
                {
                case fundamental_type::Boolean:
                    w.write("_winrt.Boolean");
                    break;
                case fundamental_type::Char:
                    w.write("_winrt.Char16");
                    break;
                case fundamental_type::Int8:
                    w.write("_winrt.Int8");
                    break;
                case fundamental_type::UInt8:
                    w.write("_winrt.UInt8");
                    break;
                case fundamental_type::Int16:
                    w.write("_winrt.Int16");
                    break;
                case fundamental_type::UInt16:
                    w.write("_winrt.UInt16");
                    break;
                case fundamental_type::Int32:
                    w.write("_winrt.Int32");
                    break;
                case fundamental_type::UInt32:
                    w.write("_winrt.UInt32");
                    break;
                case fundamental_type::Int64:
                    w.write("_winrt.Int64");
                    break;
                case fundamental_type::UInt64:
                    w.write("_winrt.UInt64");
                    break;
                case fundamental_type::Float:
                    w.write("_winrt.Single");
                    break;
                case fundamental_type::Double:
                    w.write("_winrt.Double");
                    break;
                case fundamental_type::String:
                    w.write("str");
                    break;
                default:
                    throw_invalid("invalid fundamental type");
                }
            },
            [&]([[maybe_unused]] TypeDef const& type)
            {
                w.write_python(type);
            },
            [](auto)
            {
                throw_invalid("invalid struct field type");
            });
    }

    void write_struct_field_keyword(writer& w, Field const& field)
    {
        w.write(
            "\"%\", ", bind<write_lower_snake_case_python_identifier>(field.Name()));
    }

    void write_struct_field_format(writer& w, Field const& field)
    {
        call(
            get_struct_field_semantics(field, true),
            [&](fundamental_type type)
            {
                switch (type)
                {
                case fundamental_type::Boolean:
                    w.write("p");
                    break;
                    // TODO: 'u' format string was deprecated in Python 3.3. Need to
                    // move to a supported construct
                case fundamental_type::Char:
                    w.write("u1");
                    break;
                case fundamental_type::Int8:
                    w.write("y1");
                    break;
                case fundamental_type::UInt8:
                    w.write("y1");
                    break;
                case fundamental_type::Int16:
                    w.write("h");
                    break;
                case fundamental_type::UInt16:
                    w.write("H");
                    break;
                case fundamental_type::Int32:
                    w.write("i");
                    break;
                case fundamental_type::UInt32:
                    w.write("I");
                    break;
                case fundamental_type::Int64:
                    w.write("L");
                    break;
                case fundamental_type::UInt64:
                    w.write("K");
                    break;
                case fundamental_type::Float:
                    w.write("f");
                    break;
                case fundamental_type::Double:
                    w.write("d");
                    break;
                    // TODO: 'u' format string was deprecated in Python 3.3. Need to
                    // move to a supported construct
                case fundamental_type::String:
                    w.write("u");
                    break;
                default:
                    throw_invalid("invalid fundamental type");
                }
            },
            [&]([[maybe_unused]] type_definition const& type)
            {
                XLANG_ASSERT(get_category(type) == category::struct_type);
                w.write("O");
            },
            [](auto)
            {
                throw_invalid("invalid struct field type");
            });
    }

    void write_struct_field_parse_parameter(writer& w, Field const& field)
    {
        call(
            get_struct_field_semantics(field, true),
            [&](fundamental_type)
            {
                w.write(", &_%", field.Name());
            },
            [&]([[maybe_unused]] type_definition const& type)
            {
                XLANG_ASSERT(get_category(type) == category::struct_type);
                w.write(", &_%", field.Name());
            },
            [](auto)
            {
                throw_invalid("invalid struct field type");
            });
    }

    void write_struct_field_initializer(writer& w, Field const& field)
    {
        call(
            get_struct_field_semantics(field, false),
            [&](fundamental_type)
            {
                w.write("_%", field.Name());
            },
            [&](type_definition const& type)
            {
                auto category = get_category(type);
                XLANG_ASSERT(
                    (category == category::struct_type)
                    || (category == category::enum_type));
                switch (category)
                {
                case category::enum_type:
                    w.write("static_cast<%>(_%)", type, field.Name());
                    break;
                case category::struct_type:
                    w.write("py::converter<%>::convert_to(_%)", type, field.Name());
                    break;
                }
            },
            [](auto)
            {
                throw_invalid("invalid struct field type");
            });
    }

    void write_struct_field_ref_capture(writer& w, Field const& field)
    {
        call(
            get_struct_field_semantics(field, true),
            [&](fundamental_type)
            {
            },
            [&]([[maybe_unused]] TypeDef const& type)
            {
                XLANG_ASSERT(get_category(type) == category::struct_type);
                w.write(", &_%", field.Name());
            },
            [](auto)
            {
                throw_invalid("invalid struct field type");
            });
    }

    void write_struct_constructor(writer& w, TypeDef const& type)
    {
        w.write(
            "\nPyObject* _new_@(PyTypeObject* type, PyObject* args, PyObject* kwds)\n{",
            type.TypeName());
        {
            writer::indent_guard g{w};
            w.write(R"(
auto tuple_size = PyTuple_Size(args);

if ((tuple_size == 0) && (kwds == nullptr))
{
)");
            {
                writer::indent_guard gg{w};
                write_try_catch(
                    w,
                    [&](writer& w)
                    {
                        w.write(
                            "% return_value{};\nreturn py::convert(return_value);\n",
                            type);
                    });
            }
            w.write(R"(}

if ((tuple_size == 1) && (kwds == nullptr))
{
)");
            {
                writer::indent_guard gg{w};
                w.write(R"(auto arg = PyTuple_GetItem(args, 0);
if (PyDict_Check(arg))
{
)");
                {
                    writer::indent_guard ggg{w};
                    write_try_catch(
                        w,
                        [&](writer& w)
                        {
                            w.write(
                                "auto return_value = py::convert_to<%>(arg);\nreturn py::convert(return_value);\n",
                                type);
                        });
                }
                w.write("}\n");
            }
            w.write("}\n\n");

            for (auto&& field : type.FieldList())
            {
                w.write(
                    "% _%{};\n",
                    bind<write_struct_field_var_type>(field),
                    field.Name());
            }

            {
                auto format = R"(
static const char* kwlist[] = {%nullptr};
if (!PyArg_ParseTupleAndKeywords(args, kwds, "%", const_cast<char**>(kwlist)%))
{
    return nullptr;
}

)";
                w.write(
                    format,
                    bind_each<write_struct_field_keyword>(type.FieldList()),
                    bind_each<write_struct_field_format>(type.FieldList()),
                    bind_each<write_struct_field_parse_parameter>(type.FieldList()));
            }

            if (has_custom_conversion(type))
            {
                auto format
                    = "% return_value{ };\ncustom_set(return_value, %);\nreturn py::convert(return_value);\n";
                write_try_catch(
                    w,
                    [&](writer& w)
                    {
                        w.write(
                            format,
                            type,
                            bind<write_struct_field_initializer>(
                                type.FieldList().first));
                    });
            }
            else
            {
                auto ref_captures = w.write_temp(
                    "%", bind_each<write_struct_field_ref_capture>(type.FieldList()));
                auto format
                    = "% return_value{ % };\nreturn py::convert(return_value);\n";
                write_try_catch(
                    w,
                    [&](writer& w)
                    {
                        w.write(
                            format,
                            type,
                            bind_list<write_struct_field_initializer>(
                                ", ", type.FieldList()));
                    },
                    "nullptr");
            }
        }
        w.write("}\n");
    }

    void write_struct_field_name(writer& w, Field const& field)
    {
        static const std::set<std::string_view> custom_numerics
            = {"Matrix3x2",
               "Matrix4x4",
               "Plane",
               "Quaternion",
               "Vector2",
               "Vector3",
               "Vector4"};

        auto type = field.Parent();
        if ((type.TypeNamespace() == "Windows.Foundation.Numerics")
            && (custom_numerics.find(type.TypeName()) != custom_numerics.end()))
        {
            for (char c : field.Name())
            {
                w.write(static_cast<char>(::tolower(c)));
            }
        }
        else
        {
            w.write(field.Name());
        }
    }

    void write_struct_getset_function(
        writer& w, TypeDef const& type, Field const& field)
    {
        w.write(
            "\nstatic PyObject* @_get_%(%* self, void* /*unused*/) noexcept\n{\n",
            type.TypeName(),
            field.Name(),
            bind<write_pywrapper_type>(type));
        {
            writer::indent_guard g{w};

            if (has_custom_conversion(type))
            {
                write_try_catch(
                    w,
                    [](writer& w)
                    {
                        w.write("return py::convert(custom_get(self->obj));\n");
                    });
            }
            else
            {
                write_try_catch(
                    w,
                    [&](writer& w)
                    {
                        w.write(
                            "return py::convert(self->obj.%);\n",
                            bind<write_struct_field_name>(field));
                    });
            }
        }
        w.write("}\n");

        w.write(
            "\nstatic int @_set_%(%* self, PyObject* arg, void* /*unused*/) noexcept\n{\n",
            type.TypeName(),
            field.Name(),
            bind<write_pywrapper_type>(type));
        {
            writer::indent_guard g{w};

            if (has_custom_conversion(type))
            {
                write_setter_try_catch(
                    w,
                    [&](writer& w)
                    {
                        w.write(
                            "custom_set(self->obj, py::converter<%>::convert_to(arg));\nreturn 0;\n",
                            field.Signature().Type());
                    });
            }
            else
            {
                write_setter_try_catch(
                    w,
                    [&](writer& w)
                    {
                        w.write(
                            "self->obj.% = py::converter<%>::convert_to(arg);\nreturn 0;\n",
                            bind<write_struct_field_name>(field),
                            field.Signature().Type());
                    });
            }
        }
        w.write("}\n");
    }

    void write_struct_getset_functions(writer& w, TypeDef const& type)
    {
        for (auto&& field : type.FieldList())
        {
            write_struct_getset_function(w, type, field);
        }
    }

    void write_struct_convert_functions(writer& w, TypeDef const& type)
    {
        w.write(
            "\n\nPyObject* py::converter<%>::convert(% instance) noexcept\n{\n",
            type,
            type);
        {
            writer::indent_guard g{w};

            w.write("auto type = py::get_python_type<%>();\n", type);
            w.write("if (!type)\n{\n");
            {
                writer::indent_guard gg{w};

                w.write("return nullptr;\n");
            }
            w.write("}\n\n");
            w.write("return py::wrap_struct(instance, type);\n");
        }
        w.write("}\n");

        w.write("% py::converter<%>::convert_to(PyObject* obj)\n{\n", type, type);
        {
            writer::indent_guard g{w};

            auto format = R"(throw_if_pyobj_null(obj);

auto type =  py::get_python_type<%>();

if (!type) {
    throw python_exception();
}

if (Py_TYPE(obj) == type)
{
    return reinterpret_cast<py::winrt_struct_wrapper<%>*>(obj)->obj;
}

if (!PyDict_Check(obj))
{
    PyErr_SetString(PyExc_TypeError, "expecting % or dict");
    throw python_exception();
}

)";
            w.write(format, type, type, type);

            w.write("% return_value{};\n", type);

            for (auto&& field : type.FieldList())
            {
                // PyDict_GetItemString returns borrowed reference!
                w.write(
                    "\nPyObject* py_% = PyDict_GetItemString(obj, \"%\");\n",
                    field.Name(),
                    bind<write_lower_snake_case_python_identifier>(field.Name()));
                w.write("if (!py_%) {\n", field.Name());

                {
                    writer::indent_guard gg{w};
                    w.write("PyErr_SetString(PyExc_KeyError, \"%\");\n", field.Name());
                    w.write("throw python_exception();\n");
                }

                w.write("}\n");

                if (has_custom_conversion(type))
                {
                    w.write(
                        "custom_set(return_value, converter<%>::convert_to(py_%));\n",
                        field.Signature().Type(),
                        field.Name());
                }
                else
                {
                    w.write(
                        "return_value.% = converter<%>::convert_to(py_%);\n",
                        bind<write_struct_field_name>(field),
                        field.Signature().Type(),
                        field.Name());
                }
            }

            w.write("\nreturn return_value;\n");
        }
        w.write("}");
    }

    void write_struct(writer& w, TypeDef const& type)
    {
        auto guard{w.push_generic_params(type.GenericParam())};

        w.write("\n// ----- % struct --------------------\n", type.TypeName());
        write_winrt_type_name_constant(w, type);
        write_struct_constructor(w, type);
        write_dealloc_function(w, type);
        write_struct_getset_functions(w, type);
        write_getset_table(w, type);
        write_type_slot_table(w, type);
        write_type_spec(w, type);
    }

#pragma endregion

#pragma region delegate functions
    void write_delegate_template_args(writer& w, TypeDef const& type)
    {
        if (is_ptype(type))
        {
            w.write(
                "<%>", bind_list<write_template_arg_name>(", ", type.GenericParam()));
        }
    }

    void write_delegate_type_mapper(writer& w, TypeDef const& type)
    {
        auto format = R"(template <%>
struct delegate_python_type<%%>
{
    using type = %%;
};

)";
        w.write(
            format,
            bind_list<write_template_arg>(", ", type.GenericParam()),
            type,
            bind<write_delegate_template_args>(type),
            bind<write_pyimpl_type>(type),
            bind<write_delegate_template_args>(type));
    }

    void write_delegate_param(writer& w, method_signature::param_t const& p)
    {
        w.write("auto %", bind<write_param_name>(p));
    }

    void write_delegate_callable_wrapper(writer& w, TypeDef const& type)
    {
        auto guard{w.push_generic_params(type.GenericParam())};

        auto invoke = get_delegate_invoke(type);
        method_signature signature{invoke};

        if (is_ptype(type))
        {
            w.write(
                "\ntemplate <%>",
                bind_list<write_template_arg>(", ", type.GenericParam()));
        }

        w.write("\nstruct @\n{\n", type.TypeName());
        {
            writer::indent_guard g{w};

            w.write(
                "static %% get(PyObject* callable)\n{\n",
                type,
                bind<write_delegate_template_args>(type));
            {
                writer::indent_guard gg{w};

                {
                    auto format = R"(py::delegate_callable _delegate{ callable };

return [delegate = std::move(_delegate)](%)
{
)";
                    w.write(
                        format,
                        bind_list<write_delegate_param>(", ", signature.params()));
                }
                {
                    writer::indent_guard ggg{w};

                    w.write(
                        "winrt::handle_type<py::gil_state_traits> gil_state{ PyGILState_Ensure() };\n\n");

                    std::vector<std::string> tuple_params{};
                    for (auto&& p : signature.params())
                    {
                        auto param_name = w.write_temp("%", bind<write_param_name>(p));
                        auto py_param_name = "py_"s + param_name;

                        w.write(
                            "py::pyobj_handle %{ py::convert(%) };\n",
                            py_param_name,
                            param_name);
                        tuple_params.push_back(py_param_name);
                    }

                    if (tuple_params.size() > 0)
                    {
                        w.write(
                            "\npy::pyobj_handle args{ % };\n",
                            bind<write_py_tuple_pack>(tuple_params));

                        w.write("\nif (!args) {\n");
                        {
                            writer::indent_guard gggg{w};
                            w.write("PyErr_WriteUnraisable(delegate.callable());\n");
                            w.write("throw winrt::hresult_error();\n");
                        }
                        w.write("}\n\n");
                    }
                    else
                    {
                        w.write("py::pyobj_handle args{ nullptr };\n");
                    }

                    w.write(
                        R"(py::pyobj_handle return_value{ PyObject_CallObject(delegate.callable(), args.get()) };

if (!return_value)
{
    PyErr_WriteUnraisable(delegate.callable());
    throw winrt::hresult_error();
}
)");

                    if (signature.return_signature())
                    {
                        w.write(
                            "\nreturn py::convert<%>(return_value.get());\n",
                            signature.return_signature().Type());
                    }
                }

                w.write("};\n");
            }
            w.write("};\n");
        }
        w.write("};\n");
    }
#pragma endregion

    /**
     * Writes the Python type.
     *
     * This does not wrap reference types in typing.Optional.
     *
     * @param w The writer.
     * @param type The type.
     */
    void write_python(writer& w, coded_index<TypeDefOrRef> const& type)
    {
        w.write_python(type);
    }

    /**
     * Writes the Python type signature for a parameter or return type.
     *
     * This will wrap reference types in typing.Optional.
     *
     * @param w The writer.
     * @param signature The type signature.
     */
    void write_python_type(writer& w, TypeSig const& signature)
    {
        // The type metadata doesn't have nullable annotations, so we have to
        // assume that every reference type is nullable (typing.Optional).
        // https://github.com/microsoft/xlang/issues/716

        call(
            signature.Type(),
            [&](ElementType t)
            {
                bool is_reference_type = t == ElementType::Object;

                if (is_reference_type)
                {
                    w.write("typing.Optional[");
                }

                w.write_python(t);

                if (is_reference_type)
                {
                    w.write("]");
                }
            },
            [&](GenericTypeIndex t)
            {
                w.write("typing.Optional[");
                w.write_python(t);
                w.write("]");
            },
            [&](GenericTypeInstSig t)
            {
                // type metadata does not contain nullability info, so we try
                // some heuristics to make our best guess
                auto is_nullable = !implements_iasync(get_typedef(t.GenericType()));

                if (is_nullable)
                {
                    w.write("typing.Optional[");
                }

                w.write_python(t);

                if (is_nullable)
                {
                    w.write("]");
                }
            },
            [&](GenericMethodTypeIndex)
            {
                throw_invalid("Generic methods not supported");
            },
            [&](coded_index<TypeDefOrRef> t)
            {
                auto is_reference_type = call(
                    get_type_semantics(t),
                    [&](type_definition type)
                    {
                        auto category = get_category(type);

                        return category == category::interface_type
                               || category == category::class_type
                               || category == category::delegate_type;
                    },
                    [](object_type)
                    {
                        return true;
                    },
                    [](auto&&)
                    {
                        return false;
                    });

                if (is_reference_type)
                {
                    w.write("typing.Optional[");
                }

                w.write_python(t);

                if (is_reference_type)
                {
                    w.write("]");
                }
            });
    }

    /**
     * Writes the name of the parameter in lower snake case.
     */
    void write_method_in_param_name(writer& w, method_signature::param_t const& param)
    {
        switch (get_param_category(param))
        {
        // regular parameters are just `name`
        case param_category::in:
        case param_category::pass_array:
            w.write(
                "%",
                bind<write_lower_snake_case_python_identifier>(param.first.Name()));
            break;

        // fill array parameters just require the size of the array to be allocated
        case param_category::fill_array:
            w.write("%_size", bind<write_lower_snake_case>(param.first.Name()));
            break;

        // this method only handles input parameters, receive arrays are output
        // parameters
        case param_category::out:
        case param_category::receive_array:
        default:
            throw_invalid("invalid in param category");
        }
    }

    /**
     * Writes the Python type of the parameter.
     */
    void write_method_in_param_typing(writer& w, method_signature::param_t const& param)
    {
        switch (get_param_category(param))
        {
        // regular parameters are just `name: type`
        case param_category::in:
            call(
                param.second->Type().Type(),
                [&](GenericTypeInstSig const& type)
                {
                    auto name = get_type_namespace_and_name(type.GenericType());

                    // Special case for w.f.IIterable since it accepts any Python
                    // iterable
                    if (name.first == "Windows.Foundation.Collections"
                        && name.second == "IIterable`1")
                    {
                        w.write(
                            "typing.Iterable[%]",
                            bind_list<write_python_type>(", ", type.GenericArgs()));
                    }
                    else
                    {
                        w.write_python(type);
                    }
                },
                [&](auto)
                {
                    w.write("%", bind<write_python_type>(param.second->Type()));
                });
            break;

        // array parameters accept any Python sequence-like object
        case param_category::pass_array:
            w.write(
                "typing.Sequence[%]", bind<write_python_type>(param.second->Type()));
            break;

        // fill array parameters just require the size of the array to be allocated
        case param_category::fill_array:
            w.write("_winrt.UInt32");
            break;

        // this method only handles input parameters, receive arrays are output
        // parameters
        case param_category::out:
        case param_category::receive_array:
        default:
            throw_invalid("invalid in param category");
        }
    }

    /**
     * Writes the Python `name: type` of the parameter.
     */
    void write_method_in_param_name_and_typing(
        writer& w, method_signature::param_t const& param)
    {
        w.write(
            "%: %",
            bind<write_method_in_param_name>(param),
            bind<write_method_in_param_typing>(param));
    }

    void write_method_out_param_typing(
        writer& w, method_signature::param_t const& param)
    {
        switch (get_param_category(param))
        {
        // regular parameters are just `type`
        case param_category::out:
            w.write("%", bind<write_python_type>(param.second->Type()));
            break;

        // array parameters return a Python list
        case param_category::receive_array:
        case param_category::fill_array:
            w.write("typing.List[%]", bind<write_python_type>(param.second->Type()));
            break;

        // this method only handles ouput parameters
        case param_category::in:
        case param_category::pass_array:
        default:
            throw_invalid("invalid in param category");
        }
    }

    /**
     * Writes the return Python typing.
     *
     * If a method has out parameters, the return type is a tuple that includes
     * those types in addition to the return type.
     */
    void write_return_typing(writer& w, method_signature& signature)
    {
        if (count_out_param(signature.params()) == 0)
        {
            if (signature.return_signature())
            {
                w.write(
                    "%", bind<write_python_type>(signature.return_signature().Type()));
            }
            else
            {
                w.write("None");
            }
        }
        else
        {
            if (signature.return_signature())
            {
                w.write(
                    "typing.Tuple[%, %]",
                    bind<write_python_type>(signature.return_signature().Type()),
                    bind_list<write_method_out_param_typing>(
                        ", ", filter_out_params(signature.params())));
            }
            else
            {
                if (count_out_param(signature.params()) == 1)
                {
                    w.write(
                        "%",
                        bind<write_method_out_param_typing>(
                            filter_out_params(signature.params())[0]));
                }
                else
                {
                    w.write(
                        "typing.Tuple[%]",
                        bind_list<write_method_out_param_typing>(
                            ", ", filter_out_params(signature.params())));
                }
            }
        }
    }

    void write_python_base_classes(writer& w, TypeDef const& type)
    {
        // We are using PEP 544 for interfaces.
        if (get_category(type) == category::interface_type)
        {
            w.write("typing.Protocol");

            if (is_ptype(type))
            {
                w.write(
                    "[%]",
                    bind_list<write_template_arg_name>(", ", type.GenericParam()));
            }

            // REVISIT: Consider adding required interfaces similar to implemented
            // interfaces for classes. We would need to create our own subtype
            // of typing.Protocol to support this.
        }
        else
        {
            if (is_ptype(type))
            {
                w.write(
                    "typing.Generic[%], ",
                    bind_list<write_template_arg_name>(", ", type.GenericParam()));
            }

            w.write("_winrt.Object");

            // list implemented/required interfaces as kwarg
            if (!empty(type.InterfaceImpl()))
            {
                std::vector<std::string> interfaces;

                for (auto&& ii : type.InterfaceImpl())
                {
                    auto interface_type = get_typedef(ii.Interface());

                    if (is_exclusive_to(interface_type))
                    {
                        // filter private interfaces, e.g. IBluetoothAdapter4
                        continue;
                    }

                    interfaces.push_back(
                        w.write_temp("%", bind<write_python>(ii.Interface())));
                }

                if (!interfaces.empty())
                {
                    w.write(", interfaces=[%]", bind_list(", ", interfaces));
                }
            }
        }
    }

    /**
     * Writes python TypeVar for generic type parameters
     */
    void write_python_type_vars(writer& w, TypeDef const& type)
    {
        if (is_ptype(type))
        {
            for (auto& type_param : type.GenericParam())
            {
                w.write(
                    "% = typing.TypeVar('%')\n\n",
                    bind<write_template_arg_name>(type_param),
                    bind<write_template_arg_name>(type_param));
            }
        }
    }

    /**
     * Writes a Python attribute type hint for a field.
     * @param [in]  w       The writer.
     * @param [in]  field   The field metadata.
     */
    void write_struct_field_parameter_typing(writer& w, Field const& field)
    {
        w.write(
            "%: %",
            bind<write_lower_snake_case_python_identifier>(field.Name()),
            bind<write_struct_field_python_type>(field));
    }

    /**
     * Writes a Python class definition for a struct with type hints for a .pyi file.
     * @param [in]  w       The writer.
     * @param [in]  type    The type metadata.
     */
    void write_python_typing_for_struct(writer& w, TypeDef const& type)
    {
        w.write("class @:\n", type.TypeName());
        {
            writer::indent_guard g{w};

            for (auto&& f : type.FieldList())
            {
                w.write(
                    "%: %\n",
                    bind<write_lower_snake_case_python_identifier>(f.Name()),
                    bind<write_struct_field_python_type>(f));
            }

            w.write(
                "def __init__(self, %) -> None: ...\n",
                bind_list<write_struct_field_parameter_typing>(", ", type.FieldList()));
        }
        w.write("\n");
    }

    /**
     * Writes a Python class definition for a class or interface with type hints for a
     * .pyi file.
     * @param [in]  w       The writer.
     * @param [in]  type    The type metadata.
     */
    void write_python_typing_for_object(writer& w, TypeDef const& type)
    {
        if (is_exclusive_to(type))
        {
            return;
        }

        auto guard{w.push_generic_params(type.GenericParam())};
        write_python_type_vars(w, type);

        auto ns = type.TypeNamespace();
        auto name = type.TypeName();

        if (ns == "Windows.Foundation" && name == "IClosable")
        {
            w.write("Self = typing.TypeVar('Self')\n\n");
        }

        w.write(
            "class @(%):\n", type.TypeName(), bind<write_python_base_classes>(type));
        {
            writer::indent_guard g{w};

            // write attributes

            auto property_writer = [&](Property const& property)
            {
                w.write(
                    "%: %\n",
                    bind<write_lower_snake_case_python_identifier>(property.Name()),
                    bind<write_python_type>(property.Type().Type()));
            };

            enumerate_properties(w, type, property_writer);

            // Write special methods.

            if (is_ptype(type))
            {
                w.write("if sys.version_info >= (3, 9):\n");
                {
                    writer::indent_guard gg{w};
                    w.write(
                        "def __class_getitem__(cls, key: typing.Any) -> types.GenericAlias: ...\n");
                }
            }

            // TODO: this should use the implements_x helpers but we need to
            // figure out how to get the generic type args from each interface

            if (ns == "Windows.Foundation")
            {
                if (name == "IAsyncAction" || name == "IAsyncActionWithProgress`1")
                {
                    w.write(
                        "def __await__(self) -> typing.Generator[typing.Any, None, None]: ...\n");
                }
                else if (name == "IAsyncOperation`1")
                {
                    w.write(
                        "def __await__(self) -> typing.Generator[typing.Any, None, %]: ...\n",
                        bind<write_template_arg_name>(type.GenericParam().first));
                }
                else if (name == "IAsyncOperationWithProgress`2")
                {
                    w.write(
                        "def __await__(self) -> typing.Generator[typing.Any, None, %]: ...\n",
                        bind<write_template_arg_name>(type.GenericParam().first));
                }
                else if (name == "IClosable")
                {
                    w.write("def __enter__(self: Self) -> Self: ...\n");
                    w.write(
                        "def __exit__(self, __exc_type: typing.Type[BaseException] | None, __exc_value: BaseException "
                        "| None, __traceback: typing.TracebackType | None) -> bool | None: ...\n");
                }
                else if (name == "IStringable")
                {
                    w.write("def __str__(self) -> str: ...\n");
                }
            }
            else if (ns == "Windows.Foundation.Collections")
            {
                if (name == "IIterable`1")
                {
                    w.write(
                        "def __iter__(self) -> typing.Iterator[%]: ...\n",
                        bind<write_template_arg_name>(type.GenericParam().first));
                }
                else if (name == "IIterator`1")
                {
                    w.write(
                        "def __iter__(self) -> typing.Iterator[%]: ...\n",
                        bind<write_template_arg_name>(type.GenericParam().first));
                    w.write(
                        "def __next__(self) -> %: ...\n",
                        bind<write_template_arg_name>(type.GenericParam().first));
                }
                else if (name == "IMap`2" || name == "IMapView`2")
                {
                    w.write(
                        "def __contains__(self, key: %) -> bool:...\n",
                        bind<write_template_arg_name>(type.GenericParam().first));
                    w.write("def __len__(self) -> int: ...\n");
                    w.write(
                        "def __getitem__(self, key: %) -> %: ...\n",
                        bind<write_template_arg_name>(type.GenericParam().first),
                        bind<write_template_arg_name>(
                            std::next(type.GenericParam().first)));

                    if (name == "IMap`2")
                    {
                        w.write(
                            "def __setitem__(self, key: %, value: %) -> None: ...\n",
                            bind<write_template_arg_name>(type.GenericParam().first),
                            bind<write_template_arg_name>(
                                std::next(type.GenericParam().first)));
                        w.write(
                            "def __delitem__(self, key: %) -> None: ...\n",
                            bind<write_template_arg_name>(type.GenericParam().first));
                    }
                }
                else if (name == "IVector`1" || name == "IVectorView`1")
                {
                    w.write("def __len__(self) -> int: ...\n");
                    w.write(
                        "def __getitem__(self, index: int) -> %: ...\n",
                        bind<write_template_arg_name>(type.GenericParam().first));

                    if (name == "IVector`1")
                    {
                        w.write(
                            "def __setitem__(self, index: int, value: %) -> None: ...\n",
                            bind<write_template_arg_name>(type.GenericParam().first));
                        w.write("def __delitem__(self, index: int) -> None: ...\n");
                    }
                }
            }

            if (!is_ptype(type) || is_static_class(type))
            {
                w.write("@staticmethod\n");
                w.write("def _from(obj: _winrt.Object) -> @: ...\n", type.TypeName());
            }

            // write regular methods

            auto method_writer = [&](MethodDef const& method, bool is_overloaded)
            {
                auto name = is_constructor(method) ? "__init__" : method.Name();
                method_signature signature{method};

                if (is_overloaded)
                {
                    w.write("@typing.overload\n");
                }

                if (is_static(method))
                {
                    w.write("@staticmethod\n");
                }

                // TODO: add trailing ", /" (PEP 570) to the parameters when we drop
                // support for Python 3.7
                w.write(
                    "def %(@%) -> %: ...\n",
                    bind<write_lower_snake_case_python_identifier>(name),
                    is_static(method) ? ""
                                      : (signature.has_params() ? "self, " : "self"),
                    bind_list<write_method_in_param_name_and_typing>(
                        ", ", filter_in_params(signature.params())),
                    bind<write_return_typing>(signature));
            };

            auto constructors = get_constructors(type);

            for (auto&& c : constructors)
            {
                method_writer(c, constructors.size() > 1);
            }

            enumerate_methods(w, type, method_writer);

            enumerate_events(
                w,
                type,
                [&](auto const& event)
                {
                    auto&& [add_method, remove_method] = get_event_methods(event);
                    method_writer(add_method, false);
                    method_writer(remove_method, false);
                });
        }

        w.write("\n");
    }

    /**
     * Writes a Python type alias for a .pyi file.
     *
     * This is used for creating a type alias for delagate types.
     */
    void write_python_type_alias(writer& w, TypeDef const& type)
    {
        if (is_exclusive_to(type))
        {
            return;
        }

        auto guard{w.push_generic_params(type.GenericParam())};
        write_python_type_vars(w, type);

        method_signature signature{get_delegate_invoke(type)};

        w.write(
            "@ = typing.Callable[[%], %]\n\n",
            type.TypeName(),
            bind_list<write_method_in_param_typing>(
                ", ", filter_in_params(signature.params())),
            bind<write_return_typing>(signature));
    }
} // namespace pywinrt
